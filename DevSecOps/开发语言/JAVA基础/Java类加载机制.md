- [Java类加载机制](#java类加载机制)
  - [加载方式](#加载方式)
  - [加载流程](#加载流程)
    - [加载](#加载)
    - [验证](#验证)
    - [准备](#准备)
    - [解析](#解析)
    - [初始化](#初始化)
  - [类加载器](#类加载器)
    - [类的唯一性和类加载器](#类的唯一性和类加载器)
    - [三种类加载器](#三种类加载器)
    - [双亲委派模型](#双亲委派模型)
      - [打破方式](#打破方式)

# Java类加载机制
JAVA虚拟机把描述一个类的数据从class文件加载到内存中,对其进行校验,解析,初始化为一个可以被JAVA虚拟机使用的java类型即为类加载过程.
![](./img/2021-12-21-12-25-46.png)
## 加载方式
* 静态加载
通过new 关键字创建实例对象.
```java
User user = new User();
```
* 动态加载
有两种方式,一种通过class.forName()加载,获取Class,然后调用Class的newInstance()创建实例.
```java
//会执行static代码块的内容
Class UserClass = Class.forName("com.test.User");
User user = UserClass.newInstance();
```
另一种通过类加载器的loadClass()方法来加载类,然后调用Class的newInstance()创建实例.
```java
//此时不执行static代码块的内容
Class UserClass = classLoader.loadClass("com.test.User");

User user = UserClass.newInstance();
```
## 加载流程
### 加载
1. 通过全限定类名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。
### 验证
1. 文件格式验证:文件头为0xCAFEBABY,主次版本号是否与虚拟机符合.
2. 元数据校验:主要检测是否符合语言规范.
3. 字节码验证:确定程序执行逻辑正确合法.
4. 符号引用验证:验证是否可以把符号引用转化为直接引用.
   `-Xverify:none`开关可以关闭大部分验证措施来提高加载速度.
### 准备
为类变量分配内存和设置初始值.
### 解析
虚拟机将常量池内的符号引用替换为直接引用的过程。
解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。
### 初始化
此阶段是执行 <clinit>() 方法的过程。
<clinit>() 方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并产生的。（不包括构造器中的语句。构造器是初始化对象的，类加载完成后，创建对象时候将调用的 <init>() 方法来初始化对象）
静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问.

## 类加载器
把实现类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作的代码模块称为"类加载器",将 class 文件二进制数据放入方法区内，然后在堆内（heap）创建一个 java.lang.Class 对象，Class 对象封装了类在方法区内的数据结构，并且向开发者提供了访问方法区内的数据结构的接口.

### 类的唯一性和类加载器
对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性.
即使两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类也不相等.
这里所指的“相等”，包括代表类的 Class 对象的 equals() 方法、 isAssignableFrom() 方法、isInstance() 方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况.
### 三种类加载器
Java 中的类加载器大致可以分成两类，
一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。
* 引导类加载器(Bootstrap ClassLoader)
它是由本地代码(c/c++)实现的，你根本拿不到他的引用，但是他实际存在，并且加载一些重要的类，它加载(%JAVA_HOME%\jre\lib),如rt.jar(runtime)、i18n.jar等，这些是Java的核心类。 他是用原生代码来实现的，并不继承自 java.lang.ClassLoader。
* 扩展类加载器(Extension ClassLoader)
虽说能拿到，但是我们在实践中很少用到它，它主要加载扩展目录下的jar包， %JAVA_HOME%\lib\ext
* 系统类加载器(SystemClassLoader)
它主要加载我们应用程序中的类，如Test,或者用到的第三方包,如jdbc驱动包等。除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器.
### 双亲委派模型

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。
![](./img/2021-12-21-14-28-40.png)
#### 打破方式
* 自定义类加载，重写loadclass方法
因为双亲委派的机制都是通过这个方法实现的，这个方法可以指定类通过什么类加载器来进行加载，所有如果改写他的加载规则，相当于打破双亲委派机制

* 使用线程上下文类
引入线程上下类加载器，通过java.lang.Thread类的setContextClassLoader()方法进行设置,再如果创建线程是还未设置，它会从父线程继承一个，如果在应用程序全局范围内没有设置，那么这个线程上下类加载器就是应用程序类加载器.
通过`ClassLoader cl = Thread.currentThread().getContextClassLoader();`就可以得到应用程序类加载器,然后使用这个线程上下类加载器去加载所需的spi代码，就实现了在BootstrapClassLoader中去加载用户自定义代码，即提供了父类加载器中获取到子类加载器的方法,再通过该子类加载器去加载第三方代码.