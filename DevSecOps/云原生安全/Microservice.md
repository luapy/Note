- [微服务架构](#微服务架构)
  - [基础概念](#基础概念)
    - [API GateWay](#api-gateway)
    - [IPC通信](#ipc通信)
    - [服务发现](#服务发现)
    - [熔断机制](#熔断机制)
  - [容器化部署 Docker](#容器化部署-docker)
  - [参考](#参考)

# 微服务架构
## 基础概念
微服务架构是在原来的基础上将一个应用的功能进行拆分，原始架构是将所有功能都集中在一个项目中，统一进行部署运行，而微服务将每一个功能独立为一个单独的服务运行，服务之间通过公开的API接口进行调用，进行分布式部署。 
![](img/17-34-55.png)  
![](img/17-39-01.png)
这样的好处在于可以降低系统的耦合性，各个功能之间互不影响，不会因为某个功能出现问题导致整个应用挂掉，更新某个功能代码时只需要重启该功能对应服务即可，同时进行迭代开发时不用去等待其它项目，提高开发迭代效率，并且能够快速的对原有服务进行扩展。
### API GateWay
在微服务下则需要对外提供一个统一的接口，这样对前端来说微服务架构是无感的，主要作用如下：

* 提供统一服务入口，让微服务对前台透明
* 聚合后台的服务，节省流量，提升性能
* 提供安全，过滤，流控等API管理功能
### IPC通信
而内部各个服务之间的通信方式(inter process communication)主要有几种方式  
1. REST接口(JAX-RS，Spring Boot)
2. RPC(Thrift, Dubbo)
3. 消息队列异步的通信(Kafaka ...)
### 服务发现
在真实场景中，同一个服务一般会有多个拷贝同时运行，一方面可以做负载均衡，第二进行容灾处理，主服务器出问题时，另一个备用服务器可以直接顶上。  
而这个时候就需要一个服务发现功能，因为在多个拷贝的情况下，服务之间并不知道该去访问哪一个拷贝的服务接口，同时也不适合将该信息写在项目配置中，不然目的服务端的ip一旦发生变化还要重启客户端。  
一般通过比如zookeeper做注册中心，每个服务上线时将自己注册到注册中心，下线时通过心跳机制注册中心自动将该服务踢出，客户端只需要先去访问注册中心，注册中心通过各种算法返回一个最适合的服务端，客户端再去请求得到服务端地址即可。
### 熔断机制
微服务架构下，网络结构更复杂，需要保证调用链的每一个环节出问题都不能影响到整体的运行，主要有几种方式：  
* 重试机制
* 限流
* 熔断机制
* 负载均衡
* 降级（本地缓存）

## 容器化部署 Docker
## 参考
https://zhuanlan.zhihu.com/p/376563467